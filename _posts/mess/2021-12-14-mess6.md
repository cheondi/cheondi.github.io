---
layout: post
title: 스테이지 생성방식
tags: [unity, vscode,csv]
categories: [mess]
comments : true
---
<br>
<br>
<br>
<br>

# 스테이지 생성방식
## 0.화면 구성

<center><img src="\assets\img\mess\mess6\6-1.PNG" width="80%" height="80%"></center><br>
위의 이미지에서 보면 MainPanel과 SubPanel로 나뉘어져 있고, 가운데는 Button들을 배치하였다.<br> MainPanel의 하얀색 빈 칸을 채워가며 게임을 플레이하는 방식이다.<br> 보기가 SubPanel에 위치해 있다.<br> SubPanel의 오브젝트들을 끌어서 빈 칸을 채우거나, 빨간색 커서를 옮겨서 SubPanel의 오브젝트를 터치해서 옮기는 방식도 있다.<br> 두 가지 모두 한번에 사용할 수 있다.<br>
<br>

~~~ cs
public class wordInfo
    {
        public int x; //시작 위치 x좌표
        public int y; //시작 위치 y좌표
        public int len; //단어 길이
        public bool direction; //true 가로방향 , false 세로방향
        public string word; //단어
        public List<string> words = new List<string>(); //가능한 단어들 list
        public List<string> excepts = new List<string>();//불가능 단어 list
        public bool perfect=false;//플레이 중 단어의 빈 칸을 모두 채운 것인지 확인
        public List<int> empty = new List<int>(); //단어의 빈 칸 index list
    }
    public List<wordInfo> wordLists = new List<wordInfo>();
~~~
단어 정보를 저장할 class를 만들어 List로 관리한다. 게임이 생성되기 전에 모두 초기화하고 시작하게 된다. <br>

~~~ cs
for (int i = 0; i < mainPanel.transform.childCount; i++)
{
    Destroy(mainPanel.transform.GetChild(i).gameObject);
    //MainPanel의 자식 오브젝트를 모두 파괴한다.
}
~~~
이전 스테이지에서 플레이했던 스테이지 파괴
~~~ cs
public void SetMainPanel()
    {
        var MyInfo = Backend.GameData.GetMyData("Info",new Where(), 10);
        stageNum = int.Parse(MyInfo.Rows()[0]["stage"][0].ToString());
        //뒤끝서버에서 플레이어의 스테이지 정보 불러오기
        stageText.text = stageNum.ToString()+"단계";
        if (stageNum <= 200)//스테이지 정보를 바탕으로 난이도 설정
        {
            index = 8;
            mainPanel.GetComponent<GridLayoutGroup>().cellSize = new Vector2(102f, 102f);
        }
        else if (stageNum <= 400 && stageNum > 200)
        {
            index = 9;
            mainPanel.GetComponent<GridLayoutGroup>().cellSize = new Vector2(94f, 94f);
        }
        else if (stageNum <= 600 && stageNum > 400)
        {
            index = 10;
            mainPanel.GetComponent<GridLayoutGroup>().cellSize = new Vector2(81f, 81f);
        }
        else
        {
            index = 11;
            mainPanel.GetComponent<GridLayoutGroup>().cellSize = new Vector2(75f, 75f);
        }
        tiles = new GameObject[index, index];//배열로 오브젝트 관리
        for (int i = 0; i < index; i++)
        {
            for (int j = 0; j < index; j++)
            {
                var tile = Instantiate(tilePrefab);//prefeb을 통해 tile 생성
                tile.transform.parent = mainPanel.transform;
                tiles[i, j] = tile;
                tile.transform.localScale = new Vector3(1.0f, 1.0f, 1.0f);
                //스케일 조절
                tile.transform.GetChild(0).GetComponent<RectTransform>().SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, (900 / index) - 8);
                //image 오브젝트의 자식 오브젝트인 text의 세로 길이 설정
                tile.transform.GetChild(0).GetComponent<RectTransform>().SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, (900 / index) - 8);
                //image 오브젝트의 자식 오브젝트인 text의 가로 길이 설정
                tile.transform.position = new Vector3(tile.transform.position.x,tile.transform.position.y,0f);
            }
        }
    }
~~~
<br>
먼저 MainPanel을 초기화시킨 후에, 다시 MainPanel을 재생성한다.
<br>

~~~ cs
public string[,] array;
public void SetArray()
{
    array = new string[index, index];
    for (int i = 0; i < index; i++)
    {
        for (int j = 0; j < index; j++)
        {
            array[i, j] = "0";
        }
    }
}
~~~
배열을 생성해 단어의 빈 칸과 음절이 들어갈 단어 관리
<br>
<br>
<br>

## 1.시작 단어 정보 정하기
첫 단어의 시작점은 (0,0),(0,1),(1,0),(1,1) 좌표에서 가로세로 랜덤하게 생성된다.

~~~ cs
    public void SetFirstWordInfo()
    {
        bool direction = (Random.value > 0.5f);//true or false 랜덤
        string word = "";
        wordInfo wordinfo = new wordInfo();
        wordinfo.x = Random.Range(0, 2);
        wordinfo.y = Random.Range(0, 2);
        wordinfo.len = Random.Range(3, 5);
        wordinfo.direction = direction;
        wordinfo.word = word;
        wordLists.Add(wordinfo);//리스트에 추가
        ApplyArray(wordinfo);//위에 생성해둔 array 단어 적용
    }
~~~
미리 생성해둔 "wordinfo" class로 정보를 생성하고 wordlists에 추가한다. 길이와, 단어의 시작 좌표를 랜덤으로 생성 
<br>

~~~ cs
    public void ApplyArray(wordInfo wordinfo)
    {
        if (wordinfo.direction) //가로 방향
        {
            for (int i = 0; i < wordinfo.len; i++)
            {
                array[wordinfo.x, wordinfo.y + i] = "1";
                //wordinfo의 정보에서 좌표 값을 이용해 array를 채운다.
                //단어가 들어갈 array에는 1이 들어간다.
            }
            if (wordinfo.y == 0)
            {
                array[wordinfo.x, wordinfo.y + wordinfo.len] = "-1";
                //단어를 채우고 양끝은 단어가 들어올 수 없으므로 array에 -1을 입력
                //이 때 가로방향에서 y좌표가 0이라면 왼쪽은 끝 부분이여서 오른쪽만 -1을 입력
            }
            else if (wordinfo.y + wordinfo.len == index)
            {
                array[wordinfo.x, wordinfo.y - 1] = "-1";
                //반대로 단어의 제일 끝부분이 array의 제일 끝부분에 닿는다면 왼쪽에만 -1 입력
            }
            else
            {
                array[wordinfo.x, wordinfo.y - 1] = "-1";
                array[wordinfo.x, wordinfo.y + wordinfo.len] = "-1";
                //양 쪽 모두 막혀 있지 않다면 양쪽에 -1 입력
            }
        }
        else //세로 방향
        {
            //가로 방향과 반대로 위아래로 판별
            for (int i = 0; i < wordinfo.len; i++)
            {
                array[wordinfo.x + i, wordinfo.y] = "1";
            }
            if (wordinfo.x == 0)
            {
                array[wordinfo.x + wordinfo.len, wordinfo.y] = "-1";
            }
            else if (wordinfo.x + wordinfo.len == index)
            {
                array[wordinfo.x - 1, wordinfo.y] = "-1";
            }
            else
            {
                array[wordinfo.x - 1, wordinfo.y] = "-1";
                array[wordinfo.x + wordinfo.len, wordinfo.y] = "-1";
            }
        }
    }
~~~
<br>
<br>
<br>

## 2.빈칸 지우기
빈 칸을 지운다는 말은 현재 x,y 좌표에 단어가 들어갈 수 있나 없나 판단하여 들어갈 수 없다면, -1을 채우는 방식이다. array의 모든 좌표를 확인한다.
### 1)상황 1

<center><img src="\assets\img\mess\mess6\6-2.jpg" width="80%" height="80%"></center><br>
<center><img src="\assets\img\mess\mess6\6-3.jpg" width="80%" height="80%"></center><br>
위와 같이 모서리에서 나올 수 있는 상황에서는 아래와 같이 처리하면 된다.<br>
<br>

~~~ cs
    public void EraseArray()
    {
        for (int x = 0; x < index; x++)
        {
            for (int y = 0; y < index; y++)
            {
                if (array[x, y] == "0")//빈 칸일 때 (1은 단어가 채워짐,-1은 단어가 들어갈 수 없음)
                {
                    if (x == 0)
                    {
                        if (y == 0)
                        {
                            if (array[x + 1, y] == "1" && array[x, y + 1] == "1")
                                array[x, y] = "-1";
                            else if (array[x + 1, y] == "-1" && array[x, y + 1] == "-1")
                                array[x, y] = "-1";
                        }
                        else if (y == index - 1)
                        {
                            if (array[x, y - 1] == "1" && array[x + 1, y] == "1")
                                array[x, y] = "-1";
                            else if (array[x, y - 1] == "-1" && array[x + 1, y] == "-1")
                                array[x, y] = "-1";
                        }
    //밑으로 추가적인 내용 이어짐
~~~
<br>

### 2)상황 2
<center><img src="\assets\img\mess\mess6\6-4.jpg" width="80%" height="80%"></center><br>
위와 같은 상황이 x축이 0일때 일어나는 상황들이다. 아래와 같이 처리해준다.<br>
<br>

~~~ cs
                        else
                        {
                            if (array[x + 1, y] == "1")
                            {
                                if (array[x, y - 1] == "1")
                                    array[x, y] = "-1";
                                else if (array[x, y + 1] == "1")
                                    array[x, y] = "-1";
                                else if (array[x + 2, y] == "-1")
                                    array[x, y] = "-1";
                            }
                        }
                    }
~~~

### 3)상황 3
<center><img src="\assets\img\mess\mess6\6-5.jpg" width="80%" height="80%"></center><br>
<center><img src="\assets\img\mess\mess6\6-6.jpg" width="80%" height="80%"></center><br>
<center><img src="\assets\img\mess\mess6\6-7.jpg" width="80%" height="80%"></center><br>
상황1,상황2와 같은 내용이다. 아래의 모서리에서 x축이 마지막 index일 때 동작한다.<br>
<br>

~~~ cs
                    else if (x == index - 1)
                    {
                        if (y == 0)
                        {
                            if (array[x - 1, y] == "1" && array[x, y + 1] == "1")
                                array[x, y] = "-1";
                            else if (array[x - 1, y] == "-1" && array[x, y + 1] == "-1")
                                array[x, y] = "-1";
                        }
                        else if (y == index - 1)
                        {
                            if (array[x - 1, y] == "1" && array[x, y - 1] == "1")
                                array[x, y] = "-1";
                            else if (array[x - 1, y] == "-1" && array[x, y - 1] == "-1")
                                array[x, y] = "-1";
                        }
                        else
                        {
                            if (array[x - 1, y] == "1")
                            {
                                if (array[x, y - 1] == "1")
                                    array[x, y] = "-1";
                                else if (array[x, y + 1] == "1")
                                    array[x, y] = "-1";
                                else if (array[x - 2, y] == "-1")
                                    array[x, y] = "-1";
                            }
                        }
                    }
~~~
### 4)상황 4
<center><img src="\assets\img\mess\mess6\6-8.jpg" width="50%" height="50%"><img src="\assets\img\mess\mess6\6-9.jpg" width="50%" height="50%"></center><br>
위에서 x축이 0일때 모든 모서리를 처리하여, y축이 0이거나 마지막 index일 때의 상황만을 처리하였다.<br>
<br>

~~~ cs
                    else if (y == 0)
                    {
                        if (array[x, y + 1] == "1")
                        {
                            if (array[x - 1, y] == "1")
                                array[x, y] = "-1";
                            else if (array[x + 1, y] == "1")
                                array[x, y] = "-1";
                            else if (array[x, y + 2] == "-1")
                                array[x, y] = "-1";
                        }
                    }
                    else if (y == index - 1)
                    {
                        if (array[x, y - 1] == "1")
                        {
                            if (array[x - 1, y] == "1")
                                array[x, y] = "-1";
                            else if (array[x + 1, y] == "1")
                                array[x, y] = "-1";
                            else if (array[x, y - 2] == "-1")
                                array[x, y] = "-1";
                        }
                    }
~~~

<br>

### 5)상황 5
<center><img src="\assets\img\mess\mess6\6-10.jpg" width="80%" height="80%"></center><br>
상황 5부터는 모서리 부분이 아닌 모든 부분에서 동작한다. <br>
<br>

~~~ cs
                    else
                    {
                        if (array[x + 1, y] == "1")
                        {
                            if (array[x - 1, y] == "1")
                                array[x, y] = "-1";
                            else if (array[x, y - 1] == "1")
                                array[x, y] = "-1";
                            else if (array[x, y + 1] == "1")
                                array[x, y] = "-1";
                        }
~~~

### 6)상황 6
<center><img src="\assets\img\mess\mess6\6-11.jpg" width="80%" height="80%"></center><br>
상황 5와 비슷한 경우이고 4방향을 모두 확인해야 하기 때문에 반복한다.
<br>

~~~ cs
                        else if (array[x, y + 1] == "1")
                        {
                            if (array[x, y - 1] == "1")
                                array[x, y] = "-1";
                            else if (array[x - 1, y] == "1")
                                array[x, y] = "-1";
                        }
                        else if (array[x - 1, y] == "1")
                        {
                            if (array[x, y - 1] == "1")
                                array[x, y] = "-1";
                        }
~~~

### 7)상황 7
<center><img src="\assets\img\mess\mess6\6-12.jpg" width="80%" height="80%"></center><br>
<center><img src="\assets\img\mess\mess6\6-14.jpg" width="80%" height="80%"></center><br>
위의 두 경우에 가로 방향으로 있는 경우에 만약 저 빈 칸으로 인해 단어가 세로 방향으로 채워지면서 빈 칸을 채우게 된다면, 단어가 이어지게 되면서 말도 안되는 단어가 나오게 된다.<br>
두번째 경우에도 같은 상황이 발생하게 된다.
<br>

~~~ cs
                        if (x > 1)
                        {
                            if (array[x - 1, y] == "1")
                            {
                                if (array[x - 2, y] == "-1" && array[x + 1, y] == "-1")
                                    array[x, y] = "-1";
                            }
                        }
                        if (x < index - 2)
                        {
                            if (array[x + 1, y] == "1")
                            {
                                if (array[x + 2, y] == "-1" && array[x - 1, y] == "-1")
                                    array[x, y] = "-1";
                            }
                        }
                        if (y > 1)
                        {
                            if (array[x, y - 1] == "1")
                            {
                                if (array[x, y - 2] == "-1" && array[x, y + 1] == "-1")
                                    array[x, y] = "-1";
                            }
                        }
                        if (y < index - 2)
                        {
                            if (array[x, y + 1] == "1")
                            {
                                if (array[x, y + 2] == "-1" && array[x, y - 1] == "-1")
                                    array[x, y] = "-1";
                            }
                        }
                        if (x == 1)
                        {
                            if (array[x - 1, y] == "1" && array[x + 1, y] == "-1")
                                array[x, y] = "-1";
                        }
                        if (x == index - 2)
                        {
                            if (array[x + 1, y] == "1" && array[x - 1, y] == "-1")
                                array[x, y] = "-1";
                        }
                        if (y == 1)
                        {
                            if (array[x, y - 1] == "1" && array[x, y + 1] == "-1")
                                array[x, y] = "-1";
                        }
                        if (y == index - 2)
                        {
                            if (array[x + 1, y] == "1" && array[x - 1, y] == "-1")
                                array[x, y] = "-1";
                        }
                    }
                }
            }
        }
    }
~~~

## 3.다음 단어 길이 방향 선정

array에 단어가 들어가지 말아야 할 빈 칸을 모두 처리하고 다음 단어의 정보를 생성하여 입력하여야 한다.<br>
상황에 따라 발생하는 경우가 많아 코드의 길이가 길어지게 되었다.<br>

~~~ cs
    public void ChoosePosition(int cnt)
    {
        if (wordLists.Count - 1 < cnt)
            return;
        //순서에 맞지 않게 단어가 생성된다면 return
        wordInfo nowWord = wordLists[cnt];
        int forth = EmptyArray(nowWord)[ChooseSyllable(nowWord), 0]; 
        //EmptyArray() <- 이 함수는 이전 단어에서 새로운 단어가 생성된다면 겹칠 수 있는 부분을 반환한다.(배열에서 2번 째 열은 0이라면 왼쪽 또는 위쪽의 빈 칸 갯수를 반환)
        int back = EmptyArray(nowWord)[ChooseSyllable(nowWord), 1];
        //(배열의 2번째 열이 1이라면 오른쪽 또는 아래쪽의 빈 칸 갯수를 반환)
        int wordIndex = ChooseSyllable(nowWord);
        //현재 단어가 이전 단어와 겹칠 수 있는 부분 중에서 제일 빈 칸이 많은 부분을 반환함(index를 반환하며, 같다면 랜덤)
        int indexX = nowWord.direction ? nowWord.x : nowWord.x + wordIndex;
        //겹치는 부분의 x 좌표
        int indexY = nowWord.direction ? nowWord.y + wordIndex : nowWord.y;
        //겹치는 부분의 y 좌표
        wordInfo newWord = new wordInfo();
        newWord.direction = !nowWord.direction;
        //이전 단어와 같이 똑같은 방향이라면 겹칠 수 없으므로 반대 방향이 된다.
        newWord.word = "";

        if (forth + back < 2) //앞쪽과 뒤쪽의 빈 칸의 합이 2보다 작다면, 단어의 최대 길이가 2이기 때문에 return
        {
            if (cnt >= 1)//만약 지금 단어가 index가 0(첫번째 단어를 생성하고 바로 다음 단어)이 아니라면, 이전 단어를 검사
                ChoosePosition(cnt - 1);
            else
                return;//아니라면 return
        }
        else if (forth == 1 && back == 1) //앞쪽의 빈 칸이 1이고 뒤쪽의 빈 칸이 1이라면, 단어의 길이는 3이 된다. 만약 이대로 단어가 생성되면 다음 단어를 생성이 힘들어진다.
        {
            if (cnt >= 1)//만약 지금 단어가 index가 0(첫번째 단어를 생성하고 바로 다음 단어)이 아니라면, 이전 단어를 검사
                ChoosePosition(cnt - 1);
            else
                return;//아니라면 return
        }
        else if (forth == 2 && back == 0)//앞쪽의 길이가 2이고 뒤쪽의 길이가 0일때, 길이가 3인 단어를 만들 수 있고, 다음 단어를 생성하는 부분에 문제가 없다.
        {
            newWord.len = 3;//단어의 길이는 3이 된다.
            if (newWord.direction)//가로일 때라면 y축 방향으로 겹치는 좌표보다 2칸 앞으로 땡겨서 시작점을 정한다.
            {
                newWord.x = indexX;
                newWord.y = indexY - 2;
            }
            else//세로일 때라면 x축 방향으로 겹치는 좌표보다 2칸 앞으로 땡겨서 시작점을 정한다.
            {
                newWord.x = indexX - 2;
                newWord.y = indexY;
            }
            wordLists.Add(newWord); //리스트에 추가하고
            ApplyArray(newWord); //array에 적용
        }
        else if (forth == 0 && back == 2) //위 상황과는 반대로 뒤쪽의 빈 칸 길이가 2이고 앞쪽이 0일 때
        {
            newWord.len = 3;
            newWord.x = indexX;//뒤쪽이 2이기에 시작점은 이전 단어와 겹치는 부분이 된다.
            newWord.y = indexY;
            wordLists.Add(newWord);
            ApplyArray(newWord);
        }
        else if (forth + back == 3) //앞 뒤 합이 3일 경우(4글자 단어가 됨) 
        {
            newWord.len = 4;//단어 길이 4
            if (newWord.direction)//가로 일때 
            {
                newWord.x = indexX;
                newWord.y = indexY - forth;// 앞 쪽의 빈칸에 따라 단어의 시작점이 달라진다.
            }
            else
            {
                newWord.x = indexX - forth;
                newWord.y = indexY;
            }
            wordLists.Add(newWord);
            ApplyArray(newWord);
        }
        else if (forth == 1 && back >= 3)//앞쪽으로 1칸 뒤쪽으로 3칸 이상일 때
        {
            newWord.len = 4;//길이는 4
            if (newWord.direction)
            {
                newWord.x = indexX;
                newWord.y = indexY - 1; //무조건 앞으로 한칸 당긴다.
            }
            else
            {
                newWord.x = indexX - 1;
                newWord.y = indexY;
            }
            wordLists.Add(newWord);
            ApplyArray(newWord);
        }
        else if (forth >= 3 && back == 1) // 앞쪽으로 3칸 이상 뒤쪽으로 1칸
        {
            newWord.len = 4; //길이는 4
            if (newWord.direction)
            {
                newWord.x = indexX;
                newWord.y = indexY - 2; //앞쪽으로 2칸 당겨 뒤 쪽 1칸에 딱 맞게 설정
            }
            else
            {
                newWord.x = indexX - 2;
                newWord.y = indexY;
            }
            wordLists.Add(newWord);
            ApplyArray(newWord);
        }
        //여기부터는 길이가 랜덤인 부분이 있다.
        else if (forth + back >= 4 && forth > back) // 앞뒤 합이 4보다 크고, 앞 쪽이 더 클 때
        {
            newWord.len = Random.Range(3, 5);//길이는 랜덤
            if (newWord.len == 3)//길이가 3이 되었을 때
            {
                if (newWord.direction)
                {
                    newWord.x = indexX;
                    newWord.y = indexY - 2;
                }
                else
                {
                    newWord.x = indexX - 2;
                    newWord.y = indexY;
                }
                //앞쪽으로 2칸 당긴다.
            }
            else //길이가 4가 되었을 때
            {
                if (back == 0) //만약에 뒤쪽이 0이라면
                {
                    if (newWord.direction)
                    {
                        newWord.x = indexX;
                        newWord.y = indexY - 3; //앞 쪽으로 3칸 당긴다.
                    }
                    else
                    {
                        newWord.x = indexX - 3;
                        newWord.y = indexY;
                    }
                }
                else if (back == 2) //만약 뒤쪽이 2 라면 (1은 위에서 했다.)
                {
                    if (newWord.direction)//앞쪽으로 1~3까지 랜덤하게 당긴다.
                    {
                        newWord.x = indexX;
                        newWord.y = indexY - Random.Range(1, 4);
                    }
                    else
                    {
                        newWord.x = indexX - Random.Range(1, 4);
                        newWord.y = indexY;
                    }
                }
                else//나머지 경우
                {
                    if (newWord.direction)//앞쪽으로 0~4칸 당긴다.
                    {
                        newWord.x = indexX;
                        newWord.y = indexY - Random.Range(0, 4);
                    }
                    else
                    {
                        newWord.x = indexX - Random.Range(0, 4);
                        newWord.y = indexY;
                    }
                }
            }
            wordLists.Add(newWord);
            ApplyArray(newWord);
        }
        else if (forth + back >= 4 && forth < back) //위와는 반대로 앞뒤 합이 4보다 크고, 뒤쪽이 더 길 때 (위와 동일)
        {
            newWord.len = Random.Range(3, 5);
            if (newWord.len == 3)
            {
                newWord.x = indexX;
                newWord.y = indexY;
            }
            else
            {
                if (forth == 0)
                {
                    newWord.x = indexX;
                    newWord.y = indexY;
                }
                else if (forth == 2)
                {
                    if (newWord.direction)
                    {
                        newWord.x = indexX;
                        newWord.y = indexY - Random.Range(0, 3);
                    }
                    else
                    {
                        newWord.x = indexX - Random.Range(0, 3);
                        newWord.y = indexY;
                    }
                }
                else
                {
                    if (newWord.direction)
                    {
                        newWord.x = indexX;
                        newWord.y = indexY - Random.Range(0, 4);
                    }
                    else
                    {
                        newWord.x = indexX - Random.Range(0, 4);
                        newWord.y = indexY;
                    }
                }
            }
            wordLists.Add(newWord);
            ApplyArray(newWord);
        }
~~~

<br>
최대한 많은 경우를 따지고 나름의 규칙을 만들어 단어의 위치와 길이를 선정한다.<br>
<br>

~~~ cs
    public int ChooseSyllable(wordInfo wordinfo) //단어가 생성될 수 있는 위치를 정하여 반환(이전 단어의 index로)
    {
        int index = 0;
        //단어의 길이를 판단하고, 단어의 위(왼)아래(오른)쪽 방향에 빈 칸의 갯수를 판단하고, 같다면 랜덤한 위치 반환
        if (wordinfo.len == 3 && EmptyArray(wordinfo)[0, 0] + EmptyArray(wordinfo)[0, 1] == EmptyArray(wordinfo)[1, 0] + EmptyArray(wordinfo)[1, 1] && EmptyArray(wordinfo)[0, 0] + EmptyArray(wordinfo)[0, 1] == EmptyArray(wordinfo)[2, 0] + EmptyArray(wordinfo)[2, 1])
        {
            index = Random.Range(0, wordinfo.len);
        }
        else if (wordinfo.len == 4 && EmptyArray(wordinfo)[0, 0] + EmptyArray(wordinfo)[0, 1] == EmptyArray(wordinfo)[1, 0] + EmptyArray(wordinfo)[1, 1] && EmptyArray(wordinfo)[0, 0] + EmptyArray(wordinfo)[0, 1] == EmptyArray(wordinfo)[2, 0] + EmptyArray(wordinfo)[2, 1] && EmptyArray(wordinfo)[0, 0] + EmptyArray(wordinfo)[0, 1] == EmptyArray(wordinfo)[3, 0] + EmptyArray(wordinfo)[3, 1])
        {
            index = Random.Range(0, wordinfo.len);
        }
        else // 제일 긴 쪽을 반환 
        {
            int[] plus = new int[wordinfo.len];

            for (int i = 0; i < wordinfo.len; i++)
            {
                plus[i] = EmptyArray(wordinfo)[i, 0] + EmptyArray(wordinfo)[i, 1];
            }
            int max = 0;
            for (int i = 0; i < wordinfo.len; i++)
            {
                if (max < plus[i])
                {
                    max = plus[i];
                    index = i;
                }
            }
        }
        return index;
    }
~~~
<br><br>

아래 코드는 단어가 만약 가로 방향이라면, 각 단어의 index를 돌면서 위쪽과 아래쪽의 단어가 들어갈 수 있는 빈 칸의 갯수를 저장하여 반환한다.
~~~ cs
    public int[,] EmptyArray(wordInfo wordInfo) 
    {
        int[,] empty = new int[wordInfo.len, 2]; // [0,0] <- 첫 글자의 왼(위)쪽의 빈칸 ,[0,1] <- 첫 글자의 오른(아래)쪽의 빈칸
        if (wordInfo.direction) //단어 방향이 가로일 때
        {
            for (int i = 0; i < wordInfo.len; i++) //단어의 길이만큼 index를 돌면서
            {
                if (wordInfo.x == 0)// 시작점의 x 좌표가 0일 때
                {
                    empty[i, 0] = 0; //가로 방향이기에 위쪽과 아래쪽을 확인하여야 하는데, 제일 윗줄에 있기에 빈 칸의 갯수는 0 
                    for (int j = wordInfo.x + 1; j < index; j++)//아래쪽을 확인하여야 하기에 밑으로 계속 내려가면서 확인
                    {
                        if (array[wordInfo.x + 1, wordInfo.y + i] == "1") 
                        //밑쪽에서 단어가 들어간 칸을 만났을 때(다른 단어와 겹쳐져 있어서 바로 밑에 1이 있는 경우)
                        {
                            empty[i, 1] = 0; 
                            break;
                        }
                        else if (j == index - 1 && array[j, wordInfo.y + i] == "0")
                        //제일 밑부분까지 단어가 없을 때
                        {
                            empty[i, 1] = index - 1;
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "-1")
                        //밑 부분을 확인하는 중 단어가 들어갈 수 없는 부분인 -1을 만났을 때
                        {
                            empty[i, 1] = j - wordInfo.x - 1; //-1 바로 전 칸까지를 빈 칸 수로 한다.
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "1")
                        //밑 부분을 확인하는 중 단어가 나왔을 경우
                        {
                            empty[i, 1] = j - wordInfo.x - 2; // 1이 나온 전전 칸까지 빈 칸수로 한다
                            break;
                        }
                        else if (wordInfo.y + i + 1 < index)
                        {
                            if (array[j, wordInfo.y + i + 1] == "1")
                            //밑 부분을 확인하는 중에 밑 부분 뒷 칸이 1일 경우 그 부분까지 단어가 내려간다면 단어가 이어지게 되어
                            //확인하여야 한다.
                            {
                                empty[i, 1] = j - wordInfo.x - 1;
                                break;
                            }
                        }
                        else if (wordInfo.y + i - 1 >= 0)
                        {
                            if (array[j, wordInfo.y + i - 1] == "1")
                            //밑 부분을 확인하는 중에 밑 부분 뒷 칸이 1일 경우 그 부분까지 단어가 내려간다면 단어가 이어지게 되어
                            //확인하여야 한다.
                            {
                                empty[i, 1] = j - wordInfo.x - 1;
                                break;
                            }
                        }
                    }
                }
                else if (wordInfo.x == index - 1) //시작점이 제일 아랫줄로 위의 반대로 동작된다.
                {
                    empty[i, 1] = 0;
                    for (int j = wordInfo.x - 1; j >= 0; j--)
                    {
                        if (array[wordInfo.x - 1, wordInfo.y + i] == "1")
                        {
                            empty[i, 0] = 0;
                            break;
                        }
                        else if (j == 0 && array[j, wordInfo.y + i] == "0")
                        {
                            empty[i, 0] = index - 1;
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "-1")
                        {
                            empty[i, 0] = wordInfo.x - j - 1;
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "1")
                        {
                            empty[i, 0] = wordInfo.x - j - 2;
                            break;
                        }
                        else if (wordInfo.y + i + 1 < index)
                        {
                            if (array[j, wordInfo.y + i + 1] == "1")
                            {
                                empty[i, 0] = wordInfo.x - j - 1;
                                break;
                            }
                        }
                        else if (wordInfo.y + i - 1 >= 0)
                        {
                            if (array[j, wordInfo.y + i - 1] == "1")
                            {
                                empty[i, 0] = wordInfo.x - j - 1;
                                break;
                            }
                        }
                    }
                }
                else //제일 윗줄이거나 아랫줄이 아닐 경우
                {
                    for (int j = wordInfo.x - 1; j > -1; j--)//윗줄 확인
                    {
                        if (array[wordInfo.x - 1, wordInfo.y + i] == "1")
                        //바로 윗 줄이 단어와 겹쳐져 있을 경우
                        {
                            empty[i, 0] = 0;
                            break;
                        }
                        else if (j == 0 && array[j, wordInfo.y + i] == "0")
                        //x축 0일 때 (제일 윗줄까지 아무것도 안만나고 올라간 경우)
                        {
                            empty[i, 0] = wordInfo.x;
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "-1")
                        //올라가다 단어가 들어갈 수 없는 칸을 만난 경우
                        {
                            empty[i, 0] = wordInfo.x - j - 1;
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "1")
                        //올라가다 단어를 만난 경우
                        {
                            empty[i, 0] = wordInfo.x - j - 2;
                            break;
                        }
                        else if (wordInfo.y + i + 1 < index)
                        {
                            if (array[j, wordInfo.y + i + 1] == "1")
                            //올라가다 좌우칸이 단어일 경우 (여기까지 단어가 올라갈 경우 단어가 이어지게 됨)
                            {
                                empty[i, 0] = wordInfo.x - j - 1;
                                break;
                            }
                        }
                        else if (wordInfo.y + i - 1 >= 0)
                        {
                            if (array[j, wordInfo.y + i - 1] == "1")
                            //올라가다 좌우칸이 단어일 경우 (여기까지 단어가 올라갈 경우 단어가 이어지게 됨)
                            {
                                empty[i, 0] = wordInfo.x - j - 1;
                                break;
                            }
                        }
                    }
                    for (int j = wordInfo.x + 1; j < index; j++)//내려갈 때(위와 동일)
                    {
                        if (array[wordInfo.x + 1, wordInfo.y + i] == "1")
                        {
                            empty[i, 1] = 0;
                            break;
                        }
                        else if (j == index - 1 && array[j, wordInfo.y + i] == "0")
                        {
                            empty[i, 1] = index - wordInfo.x - 1;
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "-1")
                        {
                            empty[i, 1] = j - wordInfo.x - 1;
                            break;
                        }
                        else if (array[j, wordInfo.y + i] == "1")
                        {
                            empty[i, 1] = j - wordInfo.x - 2;
                            break;
                        }
                        else if (wordInfo.y + i + 1 < index)
                        {
                            if (array[j, wordInfo.y + i + 1] == "1")
                            {
                                empty[i, 1] = j - wordInfo.x - 1;
                                break;
                            }
                        }
                        else if (wordInfo.y + i - 1 >= 0)
                        {
                            if (array[j, wordInfo.y + i - 1] == "1")
                            {
                                empty[i, 1] = j - wordInfo.x - 1;
                                break;
                            }
                        }
                    }
                }
            }
        }
        else //단어의 방향이 세로일 경우(위와 동일)
        {
            for (int i = 0; i < wordInfo.len; i++)
            {
                if (wordInfo.y == 0)
                {
                    empty[i, 0] = 0;
                    for (int j = wordInfo.y + 1; j < index; j++)
                    {
                        if (array[wordInfo.x + i, wordInfo.y + 1] == "1")
                        {
                            empty[i, 1] = 0;
                            break;
                        }
                        else if (j == index - 1 && array[wordInfo.x + i, j] == "0")
                        {
                            empty[i, 1] = index - 1;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "-1")
                        {
                            empty[i, 1] = j - wordInfo.y - 1;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "1")
                        {
                            empty[i, 1] = j - wordInfo.y - 2;
                            break;
                        }
                        else if (wordInfo.x + i - 1 >= 0)
                        {
                            if (array[wordInfo.x + i - 1, j] == "1")
                            {
                                empty[i, 1] = j - wordInfo.y - 1;
                                break;
                            }
                        }
                        else if (wordInfo.x + i + 1 < index)
                        {
                            if (array[wordInfo.x + i + 1, j] == "1")
                            {
                                empty[i, 1] = j - wordInfo.y - 1;
                                break;
                            }
                        }
                    }
                }
                else if (wordInfo.x == index - 1)
                {
                    empty[i, 1] = 0;
                    for (int j = wordInfo.y - 1; j > -1; j--)
                    {
                        if (array[wordInfo.x + i, wordInfo.y - 1] == "1")
                        {
                            empty[i, 0] = 0;
                            break;
                        }
                        else if (j == 0 && array[wordInfo.x + i, j] == "0")
                        {
                            empty[i, 0] = index - 1;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "-1")
                        {
                            empty[i, 0] = wordInfo.y - j - 1;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "1")
                        {
                            empty[i, 0] = wordInfo.y - j - 2;
                            break;
                        }
                        else if (wordInfo.x + i - 1 >= 0)
                        {
                            if (array[wordInfo.x + i - 1, j] == "1")
                            {
                                empty[i, 0] = wordInfo.y - j - 1;
                                break;
                            }
                        }
                        else if (wordInfo.x + i + 1 < index)
                        {
                            if (array[wordInfo.x + i + 1, j] == "1")
                            {
                                empty[i, 0] = wordInfo.y - j - 1;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    for (int j = wordInfo.y + 1; j < index; j++)
                    {
                        if (array[wordInfo.x + i, wordInfo.y + 1] == "1")
                        {
                            empty[i, 1] = 0;
                            break;
                        }
                        else if (j == index - 1 && array[wordInfo.x + i, j] == "0")
                        {
                            empty[i, 1] = index - wordInfo.y - 1;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "-1")
                        {
                            empty[i, 1] = j - wordInfo.y - 1;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "1")
                        {
                            empty[i, 1] = j - wordInfo.y - 2;
                            break;
                        }
                        else if (wordInfo.x + i - 1 >= 0)
                        {
                            if (array[wordInfo.x + i - 1, j] == "1")
                            {
                                empty[i, 1] = j - wordInfo.y - 1;
                                break;
                            }
                        }
                        else if (wordInfo.x + i + 1 < index)
                        {
                            if (array[wordInfo.x + i + 1, j] == "1")
                            {
                                empty[i, 1] = j - wordInfo.y - 1;
                                break;
                            }
                        }
                    }
                    for (int j = wordInfo.y - 1; j >= 0; j--)
                    {
                        if (array[wordInfo.x + i, wordInfo.y - 1] == "1")
                        {
                            empty[i, 0] = 0;
                            break;
                        }
                        else if (j == 0 && array[wordInfo.x + i, j] == "0")
                        {
                            empty[i, 0] = wordInfo.y;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "-1")
                        {
                            empty[i, 0] = wordInfo.y - j - 1;
                            break;
                        }
                        else if (array[wordInfo.x + i, j] == "1")
                        {
                            empty[i, 0] = wordInfo.y - j - 2;
                            break;
                        }
                        else if (wordInfo.x + i - 1 >= 0)
                        {
                            if (array[wordInfo.x + i - 1, j] == "1")
                            {
                                empty[i, 0] = wordInfo.y - j - 1;
                                break;
                            }
                        }
                        else if (wordInfo.x + i + 1 < index)
                        {
                            if (array[wordInfo.x + i + 1, j] == "1")
                            {
                                empty[i, 0] = wordInfo.y - j - 1;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return empty;
    }
~~~
<br>
<br>
위의 단어정보 생성 함수는 최대 2 * index(빈칸의 가로 또는 세로 길이) - 5만큼 반복되거나 단어가 더 이상 들어갈 곳이 없을 때까지 반복된다.<br>
<br>
<br>
<br><br>
<br><br>
<br>
<br><br>
<br>
<br>

[이어서] https://cheondi.github.io/mess/2021/12/14/mess6.html