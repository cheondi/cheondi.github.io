---
layout: post
title:  면접 예상 질문 목록
tags: [etc]
categories: [etc]
comments : true
---
<br>
<br>
<br>
<br>

# 면접 예상 질문 목록 정리 (07.04 수정됨)

<br>

## C#


<BR>



* 인터페이스와 추상, 가상함수

   * Virtual (가상 키워드)

     virtual 키워드는 메서드,속성, 인덱서 또는 이벤트 선언을 한정하는데 사용됩니다.파생 클래스에서 필요에 따라서 재정의(override) 할 수 있지만  필수적으로 재정의 할 필요는 없습니다.Virtual 한정자를 사용한 클래스는 완벽한 기능을 제공할 수 있습니다.

     <br>

   * Abstract (추상 키워드)

     abstract 키워드를 사용하면 불완전하여 파생 클래스에서 구현해야하는 클래스 및 클래스 멤버를 만들수 있습니다.추상클래스의 사용 목적은 여러개의 파생 클래스에서 공유할 기본 클래스의 공통적인 정의를 제공하는 것입니다. 추상 클래스는 인스턴스화할 수 없습니다.

     <br>

   * Interface (인터페이스)

     인터페이스는 abstract와 비슷하지만 멤버필드(변수)를 사용할 수 없습니다. 대신에 프로퍼티는 사용이 가능합니다.인터페이스는 보통 여러클래스에 공통적인 기능을 추가하기 위해서 사용합니다.

<br>

* 구조체와 클래스 (구조체 필드의 합이 16byte를 넘는다고 힙 할당 되지 않습니다!)

  구조체와 클래스는 코드 상으로는 전체적으로 비슷하지만, 구조체는 상속을 할 수 없고 클래스는 상속이 가능합니다. 그리고 클래스 객체는 힙에 할당되지만 구조체 객체는 스택에 할당됩니다. 하지만 구조체로 선언하였어도 힙에 할당되는 경우가 있는데, 모든 필드의 합이 16바이트가 넘을 때와 구조체 안에 클래스 타입의 필드를 가질 경우입니다.
  <br>

* 상속(Inheritance)과 다형성
  
  사람을 예를 들어 설명하자면, human이라는 클래스를 만든다고 할때 이 안에 예를 들어 박지성, 류현진, 송강호 등 다양한 직업을 모두 표현하기 위해 새로운 클래스를 만들어 설정하지 않고, human이라는 객체를 기반으로 하고,이를 상속 받아 soccerplayer나 baseballplayer 또는 actor라는 클래스에 각각의 부가 기능을 추가하고 재정의하면 됩니다. 이러한 객체를 사용하므로써 각각의 객체가 아니라 human이라는 객체로 간주하여, 형변환을 통해 사람이라는 기반 클래스로 파생클래스 전부를 컨트롤 할 수 있습니다.

<br>

* 유니티와 C#의 관계
 C#으로 작성되어 엔진 속도가 느릴 것이라는 것과는 다르게 유니티 개발진은 유니티는 C++로 작성되고 .NET API를 노출시켜서 에디터에서 C#으로도 프로그래밍할 수 있게 한 것입니다.

 <BR>

* 배열과 리스트

 둘의 차이점은 일단 배열은 동적으로 할당이 불가능하고 리스트는 가능한 것입니다. 배열의 장점은 연속된 메모리 공간으로 이루어져 있어 인덱스로 접근 시 빠르게 해당 값을 찾을 수 있습니다. 리스트는 포인터를 사용하여, 다음 데이터의 주소 값을 가지고 있기에 데이터 추가/삭제가 용이합니다. 그 말은 즉슨 데이터 크기를 동적으로 할당할 수 있다는 것입니다.

<BR>


* namespace, partial

 namespace 키워드는 관련 개체 집합을 포함하는 범위를 선언하는 데 사용됩니다. 네임스페이스를 사용하여 코드 요소를 구성하고 전역적으로 고유한 형식을 만들 수 있습니다. 이 안에는 클래스 또는 인터페이스 구조체 또는 enum 등 다양한 형식을 선언할 수 있습니다. paticial 클래스는 대규모 프로젝트를 진행하는 경우 스크립트를 분할하는 역할을 합니다.

<BR>


* 객체지향(추상화, 캡슐화, 상속성, 다형성)
  * 추상화
   
     공통의 속성이나 기능을 묶어 이름을 붙이는 것입니다.

  * 캡슐화
     
     데이터 구조와 데이터를 다루는 방법들을 결합시켜 묶는 것입니다.(변수화 함수)

  * 상속성(재사용)
     
     상위 개념의 특징을 하위 개념이 물려받는 것입니다.
  
  * 다형성

     부모클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩되는 것입니다.


<BR>


* 지역변수와 전역변수

   지역 변수는 함수 내에서 선언되고 함수 내에서 작동합니다. 전역 변수는 함수 밖에서 선언되고 프로그램 전체에서 작동합니다. 지역 변수는 기능 블럭이 입력되고 종료될 때 파괴되지만 전역 변수는 프로그램이 실행되는 동안 존재됩니다. 저장은 지역 변수는 지정하지 않으면 스택, 전역 변수는 컴파일러가 결정한 고정 위치에 저장됩니다. 

<BR>


* delegate와 event 차이

  
  가장 큰 차이점은 이벤트는 인터페이스 내부에 선언할 수 있지만 델리게이트는 선언할 수 없다는 점입니다. 델리게이트는 반드시 메서드를 참조 시켜야하고, 정의한 형식에 맞아야 합니다. 이벤트는 델리게이트를 통하여 구현하고, 하나의 이벤트는 여러개의 작업들을 추가 될 수 있어야 합니다. 이벤트는 델리게이트를 캡슐화시킨 것과 비슷합니다. 

<BR>


## 메모리

<BR>


* 힙 할당 되는 케이스와 아닌 케이스

  C# 기준으로는 new로 할당되는 모든 참조형 객체는 힙에 할당됩니다. 그 외의 지역 변수 매개 변수 저장은 스택이 합니다. (스택 정적 할당 , 힙 정적 할당) 

<BR>


* C# 박싱과 언박싱

  박싱은 값 타입의 객체를 참조 타입으로 변환하는 작업이고 반대로 언박싱은 참조 타입 객체를 값 타입으로 변환하는 작업입니다.
  

<BR>


* 오브젝트 타입에 밸류 타입을 대입하면 생기는 일

  벨류를 레퍼런스타입으로 박싱한다. 스택에 있던 벨류를 힙으로 복사 후 주소값을 할당합니다. 
<BR>


* 가비지에 대하여

  가비지 콜렉터는 사용하지 않는 메모리를 힙의 메모리가 가득차면 자동적으로 회수합니다.
<BR>


* C#에서 Struct는 가비지컬렉터가 도는지?
  
  값 타입이기 때문에 스택 영역에 메모리가 할당되고, 힙 영역에 생성되는 것이 아니기에 가비지 콜렉터는 돌지 않습니다.
  

<BR>


* LOH, SOH (라지 오브젝트 힙, 스몰 오브젝트 힙)

  가비지 콜렉션 방식으로 85KB 기준으로 작으면 SOH 크면 LOH가 관리합니다. SOH는 가비지 콜렉션이 발생하면 해제된 메모리 공간들에 사용중인 메모리들로 재배치하지만 LOH는 메모히 해제를 해도 해제된 공간은 그대로 둡니다. SOH는 0~3세대로 나눠서 메모리를 관리하고 LOH는 2세대밖에 존재하지 않습니다. 그래서 2세대 가비지 콜렉션이 일어날 때에만 사용하지 않는 메모리를 해제시킵니다. 

<BR>


## 유니티에 대한 이해

  
<BR>


* 코루틴과 Invoke

  어떠한 작업을 처리할 때 필요에 따라 시간 간격을 두고 작업을 처리할 수 있도록 도와주는 함수입니다. 메인 루틴과 함께 호출되어 실행한다. (IEnumerator, yield return)
  
<BR>


* 게임루프와 델타 타임에 대한 이해

  게임 루프는 게임이 시작되고 나면 update와 render가 반복적으로 도는 것입니다. update에는 update input, actor states, graphics states, physics, networking, user interface, audio, coroutines 등 다양한 기능들이 있습니다. 델타 타임은 유니티에서 update 함수가 매 프레임 도는데, 한 프레임 당 실행하는 시간을 뜻합니다. 성능이 좋을수록 델타타입이 짧고 않좋을수록 깁니다.
  
<BR>


* CLR 과 CIL

  Common Language Runtime, 공통 언어 런타임로 CIL CODE를 NATIVE CODE로 컴파일해주는 가상 머신입니다. CILD은 공통 중간 언어로 닷넷 고유의 객체지향 어셈블리 언어 입니다. 닷넷 환경에서 타켓 플랫폼에 관계 없이 자유롭게 개발할 수 있도록 도와주는 기능을 합니다. 

<BR>


* Mono와 IL2CPP

  MONO와 IL2CPP는 CIL CODE를 NATIVE CODE로 컴파일해주는 스크립팅 백엔드입니다. 닷넷 프레임워크에서 CLR이 수행하는 역할을 유니티에서 해주는 기능을 합니다. MONO는 CIL CODE를 NATICE CODE로 변환해주고, IL2CPP는 CIL CODE를 .NET NATIVE CODE로 변환해줍니다. 이 중에서 IL2CPP는 유니티 자체 개발입니다. MONO가 IL2CPP보다는 빠르고 성능과 보안성은 IL2CPP가 MONO보다 좋습니다.

<BR>


* Update, FixedUpdate, LateUpdate, Awake, Start, OnEnable, OnDisable, OnDestroy

  유니티 LIFE CYCLE에 대해서 알아야되는데 먼저 AWAKE - START(시작) - ONENABLED(객체가 활성화 될 때 호출하는 함수) - 1회 호출되는 함수(초기화) - FIXEDUPDATE(고정된 프레임 주기로 실행) - ON TRIGGER - ONCOLLISION - UPDATE(매 프레임마다 실행) - LATEUPDATE(업데이트 다음) - ONDISABLE - ONDESTROY - ONAPPLICATIONQUIT(종료)


<BR>


## 최적화

<BR>


* 배칭

  배칭은 여러 개의 batch를 하나로 묶는 최적화 기법인데, 크게 두가지 정도로 정적/동적 배칭으로 나뉩니다. 여기서 정적 배칭은 런타임에 움직이지 않는 메시들에 대해서만 가능합니다. 여러 개의 메시를 하나로 통합하고, 메시를 통합한 만큼, 하나의 배치로 그려줄 수 있습니다. 사용 방법은 인스펙터에서 batching static 플래그를 설정하면 됩니다. 장점은 static batching이 되더라도 컬링 연산은 원래의 메시 기준으로 이루어진다는 장점이 있습니다. 동적 배칭은 유니티에 의해 내부적으로 자동으로 수행되고, 플레이어 설정에서 dynamic batching 옵션을 켜주면 됩니다. 실제로는 제약이 너무 많아 최적화를 기대하기는 힘들고 버텍스가 300개 이상의 메시에 대해서는 적용되지 않습니다. 

<BR>


* 유니티에서의 세대별 가비지 컬렉션

  세대별 가비지 컬렉션은 메모리를 세대별로 나누어 상대적으로 오래 잔재하는 메모리에 대해 적은 빈도의 추적을 수행하게 됩니다. 0~2세대로 나뉘고 메모리를 할당하는 시점에 새로운 세대로 이를 배치하게 되며, 여러 번의 가비지 컬렉션에도 해제되지 않았을 땐 뒷 세대로 이동하게 됩니다. 

<BR>


* 드로우 콜과 배치

  드로우 콜은 오브젝트가 실제 화면에 렌더링 되려면 cpu가 가지고 있는 정보들이 gpu에 전달 되어야하므로 이러한 정보들을 전달한 뒤, cpu가 gpu에 렌더링하라고 명령을 보내는 것입니다. 배치는 dp 콜과 setpass 콜을 합친 것으로 render state changes가 아니라 set pass를 포함하고 있기에 드로우 콜보다는 좁은 의미를 가집니다. 배치는 메시 변경을 포함하지 않습니다. 메시가 달라도 메테리얼이 같으면 하나의 배치로 통합할 수 있습니다. 
  
<BR>


* 렌더링 파이프라인 (큐브 하나를 게임뷰에 그리기 위해 일어나는 일)

  화면 상에 그림을 그리는 과정을 여러 단계로 나누는 것을 렌더링 파이프라인이라고 합니다. 먼저 렌더링 파이프라인이 시작되기 전에 여러 작업을 거치는데, 먼저 그래픽스 api를 초기화 한 후 드로우 콜을 생성합니다. 이후에 렌더링 파이프라인이 진행되고 마지막으로 화면에 출력됩니다. 여기서 렌더링 파이프라인은 크게 세 파트로 나뉘는데, 애플리케이션, 지오메트리, 레스트라이저 단계로 나뉩니다. 먼저 애플리케이션 단계에서는 오브젝트를 렌더링 이전에 업데이트에서 데이터를 처리하는 단계입니다. cpu에서 대부분을 연산하는 과정이라 엄밀히 말하면 렌더링 파이프라인에 속하지 않지만 렌더링 이전에 필요한 연산을 하는 단계이기에 렌더링 파이프라인의 한 단계로 말할 수 있습니다. 준비가 끝나면 지오메트리 단계에서는 버텍스와 폴리곤을 처리하고 오브젝트 버텍스를 화면 상에 배치합니다. 

<BR>


## 컴퓨터 구조

<BR>


* 프로세스와 스레드

  프로세스와 스레드는 개념의 범위부터 다릅니다. 스레드는 프로세스 안에 포함되어 있기 때문입니다. OS가 프로세스에게 CODE/DATA/STACK/HEAP 메모리 영역을 할당해 주고 최소 작업 단위로 삼는 반면, 스레드는 프로세스 내에서 STACK 메모리 영역을 제외한 다른 메모리 영역을 같은 프로세스 내 다른 스레드와 공유합니다. 프로세스는 다른 프로세스와 정보를 공유하려면 IPC를 사용하는 등의 번거로운 과정을 거쳐야 하지만, 스레드는 기본 구조 자체가 메모리를 공유하는 구조이기 때문에 다른 스레드와 정보를 공유하기 쉽습니다. 다만 스레드의 스케줄링은 OS가 처리하지 않기 때문에 프로그래머가 직접 동기화 문제에 대응할 수 있어야 합니다.

<BR>


* API란?

  API는 애플리케이션 프로그래밍 인터페이스의 약자로, 운영체제가 응용프로그램 개발 또는 동작을 위해 제공하는 함수의 집합이라고 할 수 있습니다. 다시 말하면, API는 어플리케이션을 만들기 위한 하위 함수, 프로토콜, 도구들의 집합을 말합니다. 좋은 API는 프로그래머들이 쉽게 소프트웨어를 개발할 수 있도록 도와주며, 운영체제, 데이터베이스, 하드웨어,소프트웨어 라이브러리나 웹 기반 시스템 등 다양한 곳에서 만들어집니다. 

<BR>


* 값 형식과 참조 형식

  값 형식은 변수가 값을 담는 데이터 형식이고, 참조 형식은 변수가 값 대신 값이 있는 곳의 위치를 담는 데이터 형식입니다. 값 형식의 변수는 모두 스택에 저장되고 참조형식은 힙에 저장됩니다. 

<BR>


* 메모리구조 (코드영역, 데이터영역, 힙 영역, 스택 영역)

  메모리 구조에는 네 가지 영역이 있는데, 코드, 데이터, 힙, 스택 영역이 있습니다. 코드 영역은 코드를 실행하기 위해 제어문, 함수, 상수 등 명력문들이 저장되어 있는 영역입니다. 데이터 영역은 작성한 코드에서 전역변수, 정적변수 등이 저장되는 영역입니다. 이들의 특징을 보면 메인 함수 전에 선언되어 프로그램이 끝날 때까지 메모리에 남아있는 변수들이라는 특징이 있습니다. 힙 영역은 사용자에 의해 관리되는 영역입니다. 동적으로 할당 할 변수들이 여기에 저장됩니다. 자바나 C++에서 NEW 연산자로 생성하는 경우 또는 클래스나 참조 변수들고 HEAP 영역에 차지하게 됩니다. 스택 영역은 함수를 호출할 때 지역변수, 매개변수들이 저장되는 공간입니다. 메인 함수안에서 변수들도 포함됩니다. 함수가 종료되면 해당 함수에 할당된 변수들을 메모리에서 해제시킵니다. 

<BR>


* 리스트, 딕셔너리, 큐, 스택, SortedList, LinkedList

  자료구조에서 선형구조입니다. 선형 구조는 자료 뒤에 하나의 자료가 존재하는 것으로 자료들 같의 앞뒤 관계는 1:1 선형 관계 입니다. 반대로 비선형 구조도 있는데 트리, 그래프가 있습니다. 

<BR>


* AOT와 JIT, 인터프리터

  AOT와 JIT은 컴파일러이다. 고급 프로그래밍 언어를 사용하면서 어셈블리로 번역해주는 작업을 하는 방식에는 두 가지가 있는데 하나는 컴파일러고 하나는 인터프리터입니다. 컴파일러는 프로그램 전체를 스캔하여 모두 기계어로 번역하고, 인터프리터는 프로그램 실행 시 한 번에 한 문장씩 번역합니다. AOT는 AHEAD OG TIME의 약자로 코드 실행 전에 바이트 코드를 기계어 코드로 바꾸는 컴파일러입니다. JIT는 JUST IN TIME의 약자로 코드를 런타임에 기계어로 번역합니다. 인터프리터와 비슷하지만 JIT가 컴파일 하는 대상은 소스 코드가 아니라 최적화를 거친 바이트 언어입니다. 

<BR>


* 컴퓨터 구조에서 캐시 히트와 캐시 미스

  일단 캐시는 프로그램이 수행될 때 나타나는 지역성을 이용하여 메모리나 디스크에서 사용되었던 내용을 빠르게 접근할 수 있는 곳에 보관하고 관리하여서 이 내용을 다시 필요할 때 빠르게 불러올 수 있습니다. 이때 CPU가 참조하고자 하는 메모리가 캐시에 존재할 때 캐시 히트이고 존재하지 않는다면 캐시 미스입니다. 

<BR>


* L1, L2, L3 캐시

  L1은 코어에 제일 가까이 있으며, 데이터 입출력 속도가 가장 빠릅니다. L2 캐시는 L1 캐시보다는 코어에서 멀리 존재하지만 그래도 메모리보다는 빠릅니다. L3 캐시는 L2 캐시보다는 멀리 있지만 메모리보다는 빠릅니다. L3가 없는 cpu도 많습니다. L1은 SRAM , L2와 L3는 DRAM을 사용합니다. DRAM과 ERAM을 사용하는 L4 캐시도 존재하기는 합니다. 

<BR>


* 컨텍스트 스위칭

  컨텍스트 스위칭이란 스케줄러가 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 진행하고 있을 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업입니다. 입출력을 요청할 때, CPU 사용시간이 만료되었을 때, 자식 프로세스를 만들 때, 인터럽트 처리를 기다릴 때 등 다양한 경우에 일어납니다. 

<BR>


* 콜스택

  콜스택은 프로그램에서 현재 실행 중인 서브루틴에 관한 정보를 저장하는 스택 자료구조입니다.

<BR>


## 보안

<BR>


* PE구조

  윈도우에서 실행파일의 구조를 말한다. 종류는 실행파일, 라이브러리, 드라이브, 오브젝트 파일 계열이 있습니다. PE구조는 PE HEADER와 SECTION으로 나뉩니다.

<BR>


* 커널모드와 유저모드

  일단 커널은 운영체제의 핵심 부분으로 자원을 효율적으로 이용하기 위해서 CPU 스케줄링, 메모리관리, 입출력 관리, 파일 시스템 관리 등의 업무를 수행합니다. 이러한 커널에서 중요한 자원을 관리하기 때문에 사용자가 그 중요한 자원에 접근하지 못하도록 모드를 두가지로 나눕니다. 유저모드는 우리가 여기서 코드를 작성하거나 프로세스를 실행하는 등의 행동을 할 수 있고, 커널모드에서는 모든 자원에 접근, 명령을 할 수 있습니다. 두 모드간의 전환은 SYSTEM CALL로 전환할 수 있습니다. 

<BR>


* IOCTL

  I/0 컨트롤의 줄임말로 디바이스 드라이버들과 통신하기 위해 사용됩니다. IOCTL이 디바이스를 위한 시스템 콜을 호출하여 디바이스를 동작시킵니다. 

<BR>


* 드라이버

  운영체제와 디바이스가 통신할 수 있는 소프트웨어 구성 요소입니다. 

<BR>


* 프로세스와 모듈, 스레드

  프로세스는 CPU에 의해 처리되는 프로그램으로 실행중인 프로그램을 의미하고, 스레드는 프로세스 내에서 실행하는 여러 흐름의 단위입니다. 한 프로세스 안에 존재하는 스레드들은 프로세스의 상태를 공유합니다. 모듈은 독립되어 있는 하나의 소프트웨어 또는 하드웨어의 단위를 지칭합니다. 

<BR>


## 언어

<BR>


* C와 C++의 차이점

  일단 C는 절차지향이고 C++은 멀티패러타임 언어입니다. C++은 C에서 나온 언어기에 유사한 부분이 있습니다. 그래서 대부분의 C++의 컴파일러가 C 코드를 컴파일 할 수 있습니다.

<BR>


* C#과 C++의 차이점

  C++은 메모리를 직접 관리해야 하지만, C#은 가비지 컬렉터가 메모리를 관리하여 줍니다. 일단 C#은 닷넷 프레임워크에서만 돌아가는 한계도 있습니다. 

<BR>


## 자료구조

<BR>


* C# 자료구조의 종류 

  자료구조에는 여러 가지 종류가 있습니다. 일단 단순, 선형, 비선형, 파일 구조로 나눌 수 있습니다. 일단 단순 구조에는 정수, 실수, 문자, 문자열, BOOL이 있습니다. 선형에는 LIST, DECK, STACK, QUEUE 들이 있고, 비선형에는 GRAPH와 트리가 있습니다. 파일 구조에는 순차 ,색인, 직접 파일 등이 있습니다. 

<BR>


* 요소 전체 순회시 가장 빠른 순서대로 나열 및 BigO 표기

  hash tatble이 1로 가장 빠르고 그 뒤로 log n 인 sorted array와 트리가 있습니다. 그 뒤로 n인 array와 linked list, doubly linked list, stack , queue가 있습니다. 

<BR>



* 삽입 및 삭제의 속도가 빠른 순서대로 나열 및 BigO 표기

  삽입과 삭제가 빠른 구조는 빅오가 1로 linked list, doubly linked list, stack, hash tatble이 있고, 그 뒤로 log n의 빅오를 가지는 트리가 있고 마지막으로 sorted array가 n으로 제일 느립니다. 배열은 추가나 삽입이 불가능합니다. 

<BR>


* 랜덤 액세스가 빠른 순서대로 나열 및 BigO 표기

  배열이 big o 가 1이란 만 알고 있습니다. 

<BR>



## 디자인패턴

<BR>


* 싱글톤 패턴

  전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴입니다. 한 클래스에 한 객체만 존재하도록 제한합니다. 

<BR>


* 옵저버 패턴

  한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법입니다. 일대 다의 의존성을 가지며 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴입니다. 

<BR>


* 스트레이트지 패턴

  알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴입니다. 

<BR>


* 팩토리 패턴

  상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버로딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴입니다. 

<BR>


* 빌더 패턴

  복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법과 객체를 구현하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴입니다.

<BR>


* 커맨드 패턴

  실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴입니다. 

<BR>


* 브리지 패턴

  기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴입니다. 

<BR>


## 그래픽스

<BR>


* 버텍스 셰이더와 픽셀 셰이더

  셰이더의 종류로 3가지의 셰이더가 있습니다. 버텍스 셰이더는 물체의 정점 정보에 수학적인 연산을 함으로써 물체에 특별한 효과를 주는데 사용합니다. 정점의 정보값들을 변화시켜 물체를 옮기거나 텍스처를 바꾸거나 색깔을 바꾸는 등의 작업을 수행하고 기존의 정점은 삭제하거나 추가 할 수는 없습니다. 픽셀 셰이더는 렌더링 될 각각의 픽셀들의 색을 계산하는 방식입니다. 오직 픽셀만을 연산하므로 주변의 픽셀이나 그리는 도형에 대한 정보를 알 수 없습니다. 마지막으로 지오메트리 셰이더가 있습니다. 버텍스 셰이더가 수행된 후, 수행됩니다. 버텍스 쉐이더를 거쳐온 도형 정보를 입력받아 출력합니다. 버텍스 셰이더가 할 수 없는 점이나 선 , 삼각형 등의 도형을 생성할 수 있습니다. 지오메트리 셰이더는 테셀레이션이나 그림자 효과, 큐브 맵을 한번의 처리로 렌더링 하는 데 주로 사용됩니다. 

<BR>


* 래스터라이저

  렌더링 파이프라인의 2단계인 레스터라이져는 1단계인 정점 처리의 출력을 입력으로 받는다. 정점 처리 단계는 모델링부터 얻어진 폴리곤 메쉬의 각 정점들에 여러 변환을 적용하여 클립 공간으로 이동시켰습니다. 이러한 정점들이 래스터라이저의 입력으로 들어옵니다. 이 단계에서 각 정점들을 정점, 선분, 폴리곤 단위로 처리하는데, 보통은 폴리곤 단위로 처리합니다. 이러한 단위를 프리미티브라고 한다. 순서는 클리핑, 원근 나눗셈, 뒷면 제거, 뷰포트 전환, 스캔 전환으로 진행한다. 매개변수를 통해 설정을 조금씩 밖에 바꿀 수 없습니다. 

<BR>


* 포워드와 디퍼드 렌더링

  포워드 렌더링은 3d 공간에 존재하는 폴리곤을 픽셀화하여, 그 픽셀마다 쉐이딩과 라이팅 연산을 더하는 방식으로 묘사한합니다. 디퍼드 렌더링은 한화면에 수많은 라이팅 효과를 넣고 싶어 만든 기법으로 구현 방식은 픽셀화하여 포토샵의 레이어처럼 정보를 나누어 비디오 메모리에 저장합니다. 여기에서 각종 쉐이더와 라이팅 효과를 거쳐 화면에 보여줍니다. 

<BR>


* 디더링

  디더링은 저해상도에서 컴퓨터 도형 처리의 사실감을 높이고 매끄럽지 못하고 계단 모양으로 울툴불퉁한 윤곽선이나 대각선을 눈에 띄지 않게 하기 위해 사용한다. 사용자 눈에 보이지 않는 작은, 인접한 여러 점에 다른 색을 섞어서 사용자 눈에 보이는 색깔을 만들어 사용자가 좀 더 사실감 있는 영상을 볼 수 있게 해줍니다. 

<BR>


* 텍스처 압축 포맷

  

<BR>


* 드로우콜

<BR>


* 오클루전 컬링과 프러스텀 컬링

<BR>


* 소프트마스크

<BR>


* 스텐실

<BR>


* 알파테스트, 알파블렌딩


## 알고리즘

<BR>


* DFS 구현 방식

  깊이 우선 탐색으로 스택을 이용하여 만듭니다. 먼저 탐색 시작 노드를 스택에 삽입하고, bool 배열에 방문 처리합니다. 스택에 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 다시 방문 처리합니다. 방문하지 않은 인접 노드가 없다면 스택에서 최상단 노드를 꺼냅니다. 1번과 2번과정을 더 이상 수행할 수 없을 때까지 반복합니다.

<BR>


* DFS와 다익스트라 차이, 장단점

  다익스트라는 두 노드 간의 최단 거리를 구하는 알고리즘이고, dfs나 bfs는 경로를 탐색하는 알고리즘입니다. 다익스트라는 버텍스에 값이 있고, bfs나 dfs는 값이 모두 동일합니다. 

<BR>


* 퀵소트 버블소트

<BR>


* 가장 빠른 머지소트 구현법

<BR>


* 쿼드트리, 옥트리

<BR>


## 네트워크

<BR>


* TCP/UDP 차이

<BR>


* 리틀 엔디언, 빅 엔디언

<BR>


* 패킷 컨테이너

<BR>


* 소켓

<BR>


* P2P, 릴레이, 데디케이트 서버

<BR>


* 데드레커닝

<BR>


* 락스텝

<BR>

